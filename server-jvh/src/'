#include <iostream>
#include <fstream>
#include "client.h"
#include "server.h"
#include <videostream.pb.h>

using namespace jvh;

Client::Client (Server *server) :
    m_server (server)
{
}

bool
Client::on_hung_up (Glib::IOCondition)
{
    std::cerr << "Disconnecting client trafic" << std::endl;
    m_signal_disconnected (this);
    return false;
}

void
Client::handle_incoming_message (const videostream::FromClient& message)
{
    std::cerr << "CONTENT: " << message.ShortDebugString () << std::endl;

    switch (message.msg_case ())
    {
    case videostream::FromClient::kRequestStreamEntries:
    {
        std::cerr << "Got RequestStreamEntries" << std::endl;

        videostream::ToClient msg;
        auto& entries (*msg.mutable_stream_entries());

        // XXX: Get m_stream_entries from the server.
        for (const auto &e : m_server->stream_entries ())
        {
            auto entry = entries.add_entries ();
            entry->set_name (e.second->se_name);
            entry->set_format (e.second->se_format);
            entry->set_codec (e.second->se_codec);
        }

        send_outgoing_message (msg);
        break;
    }
    case videostream::FromClient::kSelectStreamEntry:
    {
        // TEST: Just read the file inline in chunks and send chunks one after another
        // until the while file is read. That way, we will effectively block the server from
        // handling anything until it either throws an exception or finished serving it all

        // Lookup stream entry
        std::string entry_string = message.select_stream_entry ();
        std::cout << "client requested stream entry: " << entry_string << std::endl;
        auto
    }
    default:
        // Unknown message - do nothing
        break;
    }
}

void
Client::handle_traffic ()
{
    std::cerr << "Started new client thread" << std::endl;

    while (true)
    {

    }
}


